/* This file was generated by the Pallene compiler. Do not edit by hand" */
/* Indentation and formatting courtesy of pallene/C.lua */

#include "pallene_core.h"

/* ------- */
/* Records */
/* ------- */

/* ------------------- */
/* Function Prototypes */
/* ------------------- */

static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
);
static lua_Number function_02(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* i */
    lua_Integer x2  /* j */
);
static void function_03(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* N */
    Table * x2, /* v */
    Table * x3  /* out */
);
static void function_04(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* N */
    Table * x2, /* v */
    Table * x3  /* out */
);
static void function_05(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* N */
    Table * x2, /* v */
    Table * x3  /* out */
);
static lua_Number function_06(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1  /* N */
);

/* ------------------------ */
/* Function Implementations */
/* ------------------------ */

/* $init */
static void function_01(
    lua_State *L,
    Udata *G,
    StackValue *base
) {
    	
  done:
    return;
}

/* A size_comparison/spectralnorm_pln.pln:7 */
static lua_Number function_02(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* i */
    lua_Integer x2  /* j */
) {
    lua_Number x3; /* ret1 */
    lua_Integer x4; /* ij */
    lua_Number x5;
    lua_Number x6;
    lua_Number x7;
    lua_Integer x8;
    lua_Integer x9;
    lua_Integer x10;
    lua_Number x11;
    	
    x4 = intop(+, x1, x2);
    x9 = intop(-, x4, 1);
    x10 = intop(-, x4, 2);
    x8 = intop(*, x9, x10);
    x7 = (lua_Number) x8;
    x6 = x7 * 0.5;
    x11 = (lua_Number) x1;
    x5 = x6 + x11;
    x3 = 1.0 / x5;
    goto done;
    	
  done:
    return x3;
}

/* MultiplyAv size_comparison/spectralnorm_pln.pln:13 */
static void function_03(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* N */
    Table * x2, /* v */
    Table * x3  /* out */
) {
    lua_Integer x4; /* i */
    lua_Number x5; /* s */
    lua_Integer x6; /* j */
    lua_Number x7;
    lua_Number x8;
    lua_Number x9;
    	
    for(
        lua_Integer start01 = 1, limit01 = x1, step01 = 1;
        (step01 >= 0 ? start01 <= limit01 : start01 >= limit01);
        start01 = intop(+, start01, step01)
    ){
        x4 = start01;
        x5 = 0.0;
        for(
            lua_Integer start02 = 1, limit02 = x1, step02 = 1;
            (step02 >= 0 ? start02 <= limit02 : start02 >= limit02);
            start02 = intop(+, start02, step02)
        ){
            x6 = start02;
            {
                StackValue *old_stack = L->stack;
                x8 = function_02(L, G, base + 0, x4, x6);
                base = L->stack + (base - old_stack);
            }
            {
                pallene_renormalize_array(L, x2, x6, 17);
                TValue *slot = &x2->array[x6 - 1];
                if (PALLENE_UNLIKELY(!ttisfloat(slot))) {
                    pallene_runtime_tag_check_error(L,
                        17, LUA_TNUMFLT, rawtt(slot),
                        "array element");
                }
                x9 = fltvalue(slot);
            }
            x7 = x8 * x9;
            x5 = x5 + x7;
        }
        {
            pallene_renormalize_array(L, x3, x4, 19);
            TValue *slot = &x3->array[x4 - 1];
            setfltvalue(slot, x5);
        }
    }
    	
  done:
    return;
}

/* MultiplyAtv size_comparison/spectralnorm_pln.pln:24 */
static void function_04(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* N */
    Table * x2, /* v */
    Table * x3  /* out */
) {
    lua_Integer x4; /* i */
    lua_Number x5; /* s */
    lua_Integer x6; /* j */
    lua_Number x7;
    lua_Number x8;
    lua_Number x9;
    	
    for(
        lua_Integer start03 = 1, limit03 = x1, step03 = 1;
        (step03 >= 0 ? start03 <= limit03 : start03 >= limit03);
        start03 = intop(+, start03, step03)
    ){
        x4 = start03;
        x5 = 0.0;
        for(
            lua_Integer start04 = 1, limit04 = x1, step04 = 1;
            (step04 >= 0 ? start04 <= limit04 : start04 >= limit04);
            start04 = intop(+, start04, step04)
        ){
            x6 = start04;
            {
                StackValue *old_stack = L->stack;
                x8 = function_02(L, G, base + 0, x6, x4);
                base = L->stack + (base - old_stack);
            }
            {
                pallene_renormalize_array(L, x2, x6, 28);
                TValue *slot = &x2->array[x6 - 1];
                if (PALLENE_UNLIKELY(!ttisfloat(slot))) {
                    pallene_runtime_tag_check_error(L,
                        28, LUA_TNUMFLT, rawtt(slot),
                        "array element");
                }
                x9 = fltvalue(slot);
            }
            x7 = x8 * x9;
            x5 = x5 + x7;
        }
        {
            pallene_renormalize_array(L, x3, x4, 30);
            TValue *slot = &x3->array[x4 - 1];
            setfltvalue(slot, x5);
        }
    }
    	
  done:
    return;
}

/* MultiplyAtAv size_comparison/spectralnorm_pln.pln:35 */
static void function_05(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1, /* N */
    Table * x2, /* v */
    Table * x3  /* out */
) {
    luaD_checkstack(L, 1);
    Table * x4; /* u */
    	
    x4 = pallene_createtable(L, 0, 0);
    sethvalue(L, s2v(base + 0), x4);
    luaC_condGC(L, L->top = base + 1, (void)0);
    {
        StackValue *old_stack = L->stack;
        function_03(L, G, base + 1, x1, x2, x4);
        base = L->stack + (base - old_stack);
    }
    {
        StackValue *old_stack = L->stack;
        function_04(L, G, base + 1, x1, x4, x3);
        base = L->stack + (base - old_stack);
    }
    	
  done:
    return;
}

/* Approximate size_comparison/spectralnorm_pln.pln:41 */
static lua_Number function_06(
    lua_State *L,
    Udata *G,
    StackValue *base,
    lua_Integer x1  /* N */
) {
    luaD_checkstack(L, 2);
    lua_Number x2; /* ret1 */
    Table * x3; /* u */
    lua_Integer x4; /* i */
    Table * x5; /* v */
    lua_Integer x6; /* _ */
    lua_Number x7; /* vBv */
    lua_Number x8; /* vv */
    lua_Integer x9; /* i */
    lua_Number x10; /* ui */
    lua_Number x11; /* vi */
    lua_Number x12;
    lua_Number x13;
    lua_Number x14;
    	
    x3 = pallene_createtable(L, 0, 0);
    sethvalue(L, s2v(base + 0), x3);
    luaC_condGC(L, L->top = base + 1, (void)0);
    for(
        lua_Integer start05 = 1, limit05 = x1, step05 = 1;
        (step05 >= 0 ? start05 <= limit05 : start05 >= limit05);
        start05 = intop(+, start05, step05)
    ){
        x4 = start05;
        {
            pallene_renormalize_array(L, x3, x4, 45);
            TValue *slot = &x3->array[x4 - 1];
            setfltvalue(slot, 1.0);
        }
    }
    x5 = pallene_createtable(L, 0, 0);
    sethvalue(L, s2v(base + 1), x5);
    luaC_condGC(L, L->top = base + 2, (void)0);
    for(
        lua_Integer start06 = 1, limit06 = 10, step06 = 1;
        (step06 >= 0 ? start06 <= limit06 : start06 >= limit06);
        start06 = intop(+, start06, step06)
    ){
        x6 = start06;
        {
            StackValue *old_stack = L->stack;
            function_05(L, G, base + 2, x1, x3, x5);
            base = L->stack + (base - old_stack);
        }
        {
            StackValue *old_stack = L->stack;
            function_05(L, G, base + 2, x1, x5, x3);
            base = L->stack + (base - old_stack);
        }
    }
    x7 = 0.0;
    x8 = 0.0;
    for(
        lua_Integer start07 = 1, limit07 = x1, step07 = 1;
        (step07 >= 0 ? start07 <= limit07 : start07 >= limit07);
        start07 = intop(+, start07, step07)
    ){
        x9 = start07;
        {
            pallene_renormalize_array(L, x3, x9, 58);
            TValue *slot = &x3->array[x9 - 1];
            if (PALLENE_UNLIKELY(!ttisfloat(slot))) {
                pallene_runtime_tag_check_error(L,
                    58, LUA_TNUMFLT, rawtt(slot),
                    "array element");
            }
            x10 = fltvalue(slot);
        }
        {
            pallene_renormalize_array(L, x5, x9, 59);
            TValue *slot = &x5->array[x9 - 1];
            if (PALLENE_UNLIKELY(!ttisfloat(slot))) {
                pallene_runtime_tag_check_error(L,
                    59, LUA_TNUMFLT, rawtt(slot),
                    "array element");
            }
            x11 = fltvalue(slot);
        }
        x12 = x10 * x11;
        x7 = x7 + x12;
        x13 = x11 * x11;
        x8 = x8 + x13;
    }
    x14 = x7 / x8;
    x2 = sqrt(x14);
    goto done;
    	
  done:
    return x2;
}

/* ------- */
/* Exports */
/* ------- */

static int function_01_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 0)) {
        pallene_runtime_arity_error(L, "$init", 0, nargs);
    }
    	
    function_01(L, G, L->top);
    return 0;
}

static int function_06_lua(lua_State *L)
{
    StackValue *base = L->ci->func;
    CClosure *func = clCvalue(s2v(base));
    Udata *G = uvalue(&func->upvalue[0]);
    	
    int nargs = lua_gettop(L);
    if (PALLENE_UNLIKELY(nargs != 1)) {
        pallene_runtime_arity_error(L, "Approximate", 1, nargs);
    }
    	
    lua_Integer x1;
    	
    if (PALLENE_UNLIKELY(!ttisinteger(s2v(base + 1)))) {
        pallene_runtime_tag_check_error(L,
            41, LUA_TNUMINT, rawtt(s2v(base + 1)),
            "argument '%s'", "N");
    }
    x1 = ivalue(s2v(base + 1));
    	
    lua_Number ret1;
    ret1 = function_06(L, G, L->top, x1);
    setfltvalue(s2v(L->top), ret1);
    L->top++;
    return 1;
}

int luaopen_size_comparison_spectralnorm_pln(lua_State *L)
{
    luaL_checkversion(L);
    	
    lua_newuserdatauv(L, 0, 0);
    int globals = lua_gettop(L);
    	
    lua_createtable(L, 2, 0);
    int closures = lua_gettop(L);
    	
    lua_newtable(L);
    int export_table = lua_gettop(L);
    	
    /* Closures */
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_01_lua, 1);
    lua_seti(L, closures, 1);
    	
    lua_pushvalue(L, globals);
    lua_pushcclosure(L, function_06_lua, 1);
    lua_seti(L, closures, 2);
    	
    /* Global values */
    	
    // Run toplevel statements & initialize globals
    lua_geti(L, closures, 1);
    lua_call(L, 0, 0);
    	
    /* Exports */
    	
    lua_pushstring(L, "Approximate");
    lua_geti(L, closures, 2);
    lua_settable(L, export_table);
    	
    lua_pushvalue(L, export_table);
    return 1;
}

