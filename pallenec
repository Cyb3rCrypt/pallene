#!/usr/bin/env lua

local argparse = require "argparse"

local driver = require "pallene.driver"
local util = require "pallene.util"

local p = argparse("pallenec", "Pallene compiler")
p:argument("source_file", "File to compile")
p:flag("--emit-c", "Generate a .c file instead of an .so file")
p:flag("--emit-asm", "Generate a .s file instead of an .so file")
p:flag("--compile-c", "Compile a .c file generated by --emit-c")
p:flag("--dump-ast", "Print ast from a .pln file")
p:flag("--dump-checker", "Print checker's ast from a .pln file")
p:flag("--dump-ir", "Print toir's ast from a .pln file")
p:flag("--dump-uninitialized", "Print uninitialized's ast from a .pln file")
p:flag("--dump-constant_propagation", "Print constant_propagation's ast from a .pln file")
local args = p:parse()

-- For compilation errors that don't happen inside a source file.
-- Inspired by gcc, eg. "gcc: fatal error: no input files".
local compiler_name = arg[0]

local function pallenec_abort(fmt, ...)
    return util.abort(compiler_name .. ": " .. string.format(fmt, ...))
end

local function compile(in_ext, out_ext)
    local ok, errs = driver.compile(
        compiler_name, in_ext, out_ext, args.source_file)
    if not ok then
        util.abort(table.concat(errs, "\n"))
    end
end

local function compile_internal(filename, stop_after)
    local ok, errs = driver.compile_internal(filename, stop_after, true)
    if not ok then
        util.abort(table.concat(errs, "\n"))
    end
end

local flags = {}
if args.emit_c    then table.insert(flags, "--emit-c") end
if args.emit_asm  then table.insert(flags, "--emit-asm") end
if args.compile_c then table.insert(flags, "--compile-c") end
if args.dump_ast then table.insert(flags, "--dump-ast") end
if args.dump_checker then table.insert(flags, "--dump-checker") end
if args.dump_ir then table.insert(flags, "--dump-ir") end
if args.dump_uninitialized then table.insert(flags, "--dump-uninitialized") end
if args.dump_constant_propagation then
    table.insert(flags, "--dump-constant_propagation")
end

if #flags >= 2 then
    local conflicting = table.concat(flags, " and ")
    pallenec_abort("flags %s are mutually exclusive", conflicting)
end

if     #flags == 0    then compile("pln", "so")
elseif args.emit_c    then compile("pln", "c")
elseif args.emit_asm  then compile("c",   "s")
elseif args.compile_c then compile("c" ,  "so")
elseif args.dump_ast then compile_internal(args.source_file, "parser")
elseif args.dump_checker then compile_internal(args.source_file, "checker")
elseif args.dump_ir then compile_internal(args.source_file, "to_ir")
elseif args.dump_uninitialized then compile_internal(args.source_file,
                                        "uninitialized")
elseif args.dump_constant_propagation then compile_internal(args.source_file,
                                        "constant_propagation")
else
    error("impossible")
end
