#define _POSIX_C_SOURCE 199309L

#include <stdio.h>
#include <time.h>
/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

struct crecord_point {
    lua_Number f1 /* x */;
    lua_Number f2 /* y */;
};

static void crecord_index_point_x(lua_State *L, Udata *u, TValue *out)
{
    setfltvalue(out, ((struct crecord_point *)getudatamem(u))->f1);
}

static void crecord_newindex_point_x(lua_State *L, Udata *u, TValue *v)
{
    if (PALLENE_UNLIKELY(!ttisfloat(v))) {
        pallene_runtime_record_type_error(L, "x", LUA_TNUMFLT, rawtt(v));
    }
    ((struct crecord_point *)getudatamem(u))->f1 = fltvalue(v);
}

static void crecord_index_point_y(lua_State *L, Udata *u, TValue *out)
{
    setfltvalue(out, ((struct crecord_point *)getudatamem(u))->f2);
}

static void crecord_newindex_point_y(lua_State *L, Udata *u, TValue *v)
{
    if (PALLENE_UNLIKELY(!ttisfloat(v))) {
        pallene_runtime_record_type_error(L, "y", LUA_TNUMFLT, rawtt(v));
    }
    ((struct crecord_point *)getudatamem(u))->f2 = fltvalue(v);
}

static int crecord_index(lua_State *L)
{
    Udata *u = uvalue(s2v(L->ci->func + 1));
    TValue *v = s2v(L->ci->func + 2);
    if (PALLENE_UNLIKELY(!ttisstring(v))) {
        pallene_runtime_record_nonstr_error(L, rawtt(v));
    }
    Table *t = hvalue(u->metatable->array);
    const TValue *f = luaH_getstr(t, tsvalue(v));
    if (PALLENE_UNLIKELY(!ttisfunction(f))) {
        pallene_runtime_record_index_error(L, svalue(v));
    }
    void (*getfield)(lua_State *, Udata *, TValue *) =
    (void (*)(lua_State *, Udata *, TValue *))fvalue(f);
    getfield(L, u, v);
    return 1;
}

static int crecord_newindex(lua_State *L)
{
    Udata *u = uvalue(s2v(L->ci->func + 1));
    TValue *v = s2v(L->ci->func + 2);
    if (PALLENE_UNLIKELY(!ttisstring(v))) {
        pallene_runtime_record_nonstr_error(L, rawtt(v));
    }
    Table *t = hvalue(u->metatable->array + 1);
    const TValue *f = luaH_getstr(t, tsvalue(v));
    if (PALLENE_UNLIKELY(!ttisfunction(f))) {
        pallene_runtime_record_index_error(L, svalue(v));
    }
    void (*setfield)(lua_State *, Udata *, TValue *) =
    (void (*)(lua_State *, Udata *, TValue *))fvalue(f);
    setfield(L, u, s2v(L->ci->func + 3));
    return 0;
}

static Udata * function_create_pallene(
    lua_State * L,
    lua_Number x1 /* x */,
    lua_Number x2 /* y */
){
    CClosure * x3 = clCvalue(s2v(L->ci->func));
    Udata * x4 /* upvalue table */ = uvalue(&x3->upvalue[0]);
    UValue * x5 /* upvalue array */ = x4->uv;
    (void)x5;
    {
        luaC_condGC(L, {
        }, {
        });
        Udata * x6 = luaS_newudata(L, sizeof(struct crecord_point), 0);
        x6->metatable = hvalue( &x5[5].uv );
        ((struct crecord_point *)getudatamem(x6))->f1 = x1;
        ((struct crecord_point *)getudatamem(x6))->f2 = x2;
        return x6;
    }
}

static int function_create_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    int x5 /* nargs */ = cast_int(L->top - (x4 + 1));
    if (PALLENE_UNLIKELY(x5 != 2)) {
        pallene_runtime_arity_error(L, 2, x5);
    }
    TValue* x6 = s2v(x4 + 1);
    if (PALLENE_UNLIKELY(!ttisfloat(x6))) {
        pallene_runtime_argument_type_error(L, "x", 6, LUA_TNUMFLT, x6);
    }
    TValue* x7 = s2v(x4 + 2);
    if (PALLENE_UNLIKELY(!ttisfloat(x7))) {
        pallene_runtime_argument_type_error(L, "y", 6, LUA_TNUMFLT, x7);
    }
    lua_Number x8 = fltvalue(s2v(x4 + 1));
    lua_Number x9 = fltvalue(s2v(x4 + 2));
    Udata * x10 /* ret */ = function_create_pallene(L, x8, x9);
    setuvalue(L, s2v(L->top), x10);
    api_incr_top(L);
    return 1;
}

static lua_Number function_run_pallene(
    lua_State * L,
    Udata * x1 /* p */
){
    CClosure * x2 = clCvalue(s2v(L->ci->func));
    Udata * x3 /* upvalue table */ = uvalue(&x2->upvalue[0]);
    UValue * x4 /* upvalue array */ = x3->uv;
    (void)x4;
    {
        return ((struct crecord_point *)getudatamem(x1))->f1;
    }
}

static int function_run_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    int x5 /* nargs */ = cast_int(L->top - (x4 + 1));
    if (PALLENE_UNLIKELY(x5 != 1)) {
        pallene_runtime_arity_error(L, 1, x5);
    }

    struct timespec before, after;
    clock_gettime(CLOCK_MONOTONIC, &before);

    TValue* x6 = s2v(x4 + 1);
    if (PALLENE_UNLIKELY(!(ttisfulluserdata(x6) && uvalue(x6)->metatable == hvalue( &x3[5].uv )))) {
        pallene_runtime_argument_type_error(L, "p", 10, LUA_TUSERDATA, x6);
    }
    Udata * x7 = uvalue(s2v(x4 + 1));

    clock_gettime(CLOCK_MONOTONIC, &after);
    printf("%ld\n",
        after.tv_nsec - before.tv_nsec +
        (after.tv_sec - before.tv_sec) * 1000000000);


    lua_Number x8 /* ret */ = function_run_pallene(L, x7);
    setfltvalue(s2v(L->top), x8);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_capiudatacheck_pallene(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Udata * x1 = luaS_newudata(L, 0, 8);
    UValue * x2 = x1->uv;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0].uv , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__newindex");
    setsvalue(L,  &x2[1].uv , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x5 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[2].uv , x5);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x5))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x6 = luaS_new(L, "x");
    setsvalue(L,  &x2[3].uv , x6);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x6))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x7 = luaS_new(L, "y");
    setsvalue(L,  &x2[4].uv , x7);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x7))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* point */
    Table * x8 = luaH_new(L);
    luaH_resize(L, x8, 2, 3);
    Table * x9 = luaH_new(L);
    luaH_resize(L, x9, 0, 2);
    TValue x10;
    setfvalue(&x10, (int(*)(lua_State *))crecord_index_point_x);
    TValue * x11 =  &x2[3].uv ;
    TString * x12 = tsvalue(x11);
    TValue x13;
    setsvalue(L, &x13, x12);
    TValue * x14 = luaH_newkey(L, x9, &x13);
    setobj(L, x14, &x10);
    if (iscollectable(&x10) && isblack(obj2gco(x9)) && iswhite(gcvalue(&x10))) {
        luaC_barrierback_(L, obj2gco(x9));
    }
    TValue x15;
    setfvalue(&x15, (int(*)(lua_State *))crecord_index_point_y);
    TValue * x16 =  &x2[4].uv ;
    TString * x17 = tsvalue(x16);
    TValue x18;
    setsvalue(L, &x18, x17);
    TValue * x19 = luaH_newkey(L, x9, &x18);
    setobj(L, x19, &x15);
    if (iscollectable(&x15) && isblack(obj2gco(x9)) && iswhite(gcvalue(&x15))) {
        luaC_barrierback_(L, obj2gco(x9));
    }
    sethvalue(L, &x8->array[0], x9);
    Table * x20 = luaH_new(L);
    luaH_resize(L, x20, 0, 2);
    TValue x21;
    setfvalue(&x21, (int(*)(lua_State *))crecord_newindex_point_x);
    TValue * x22 =  &x2[3].uv ;
    TString * x23 = tsvalue(x22);
    TValue x24;
    setsvalue(L, &x24, x23);
    TValue * x25 = luaH_newkey(L, x20, &x24);
    setobj(L, x25, &x21);
    if (iscollectable(&x21) && isblack(obj2gco(x20)) && iswhite(gcvalue(&x21))) {
        luaC_barrierback_(L, obj2gco(x20));
    }
    TValue x26;
    setfvalue(&x26, (int(*)(lua_State *))crecord_newindex_point_y);
    TValue * x27 =  &x2[4].uv ;
    TString * x28 = tsvalue(x27);
    TValue x29;
    setsvalue(L, &x29, x28);
    TValue * x30 = luaH_newkey(L, x20, &x29);
    setobj(L, x30, &x26);
    if (iscollectable(&x26) && isblack(obj2gco(x20)) && iswhite(gcvalue(&x26))) {
        luaC_barrierback_(L, obj2gco(x20));
    }
    sethvalue(L, &x8->array[1], x20);
    TValue * x31 =  &x2[0].uv ;
    TString * x32 = tsvalue(x31);
    TValue x33;
    setsvalue(L, &x33, x32);
    TValue * x34 = luaH_newkey(L, x8, &x33);
    setfvalue(x34, (int(*)(lua_State *))crecord_index);
    TValue * x35 =  &x2[1].uv ;
    TString * x36 = tsvalue(x35);
    TValue x37;
    setsvalue(L, &x37, x36);
    TValue * x38 = luaH_newkey(L, x8, &x37);
    setfvalue(x38, (int(*)(lua_State *))crecord_newindex);
    TValue * x39 =  &x2[2].uv ;
    TString * x40 = tsvalue(x39);
    TValue x41;
    setsvalue(L, &x41, x40);
    TValue * x42 = luaH_newkey(L, x8, &x41);
    setbvalue(x42, 0);
    sethvalue(L,  &x2[5].uv , x8);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x8))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* create */
    CClosure* x43 = luaF_newCclosure(L, 1);
    x43->f = function_create_lua;
    setuvalue(L, &x43->upvalue[0], x1);
    TValue x44; setclCvalue(L, &x44, x43);
    setobj(L,  &x2[6].uv , &x44);
    if (iscollectable(&x44) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x44))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* run */
    CClosure* x45 = luaF_newCclosure(L, 1);
    x45->f = function_run_lua;
    setuvalue(L, &x45->upvalue[0], x1);
    TValue x46; setclCvalue(L, &x46, x45);
    setobj(L,  &x2[7].uv , &x46);
    if (iscollectable(&x46) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x46))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x47 = L->top;
    setuvalue(L, s2v(x47), x1); x47++;
    L->top = x47;
    lua_createtable(L, 0, 2);
    lua_pushstring(L, "create");
    setobj(L, s2v(L->top),  &x2[6].uv ); api_incr_top(L);
    lua_settable(L, -3);
    lua_pushstring(L, "run");
    setobj(L, s2v(L->top),  &x2[7].uv ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

