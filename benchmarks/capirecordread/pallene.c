#define _POSIX_C_SOURCE 199309L

#include <stdio.h>
#include <time.h>
/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

static lua_Number function_run_pallene(
    lua_State * L,
    Table * x1 /* a */
){
    CClosure * x2 = clCvalue(s2v(L->ci->func));
    Udata * x3 /* upvalue table */ = uvalue(&x2->upvalue[0]);
    UValue * x4 /* upvalue array */ = x3->uv;
    (void)x4;
    {
    struct timespec before, after;
    clock_gettime(CLOCK_MONOTONIC, &before);
        TValue * x6 =  &x4[3].uv ;
        TString * x7 = tsvalue(x6);
        TValue * x8 = (TValue *)luaH_getstr(x1, x7);
        if (PALLENE_UNLIKELY(!ttisfloat(x8))) {
            pallene_runtime_lrecord_type_error(
                L, "field", 2, LUA_TNUMFLT, rawtt(x8)
            );
        }
        lua_Number x5 = fltvalue(x8);
    clock_gettime(CLOCK_MONOTONIC, &after);
    printf("%ld\n",
        after.tv_nsec - before.tv_nsec +
        (after.tv_sec - before.tv_sec) * 1000000000);
        lua_Number x9 /* x */ = x5;
        return x9;
    }
}

static int function_run_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    int x5 /* nargs */ = cast_int(L->top - (x4 + 1));
    if (PALLENE_UNLIKELY(x5 != 1)) {
        pallene_runtime_arity_error(L, 1, x5);
    }
    TValue* x6 = s2v(x4 + 1);
    if (PALLENE_UNLIKELY(!ttistable(x6))) {
        pallene_runtime_argument_type_error(L, "a", 1, LUA_TTABLE, x6);
    }
    Table * x7 = hvalue(s2v(x4 + 1));
    lua_Number x8 /* ret */ = function_run_pallene(L, x7);
    setfltvalue(s2v(L->top), x8);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_capirecordread_pallene(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Udata * x1 = luaS_newudata(L, 0, 5);
    UValue * x2 = x1->uv;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0].uv , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__newindex");
    setsvalue(L,  &x2[1].uv , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x5 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[2].uv , x5);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x5))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x6 = luaS_new(L, "field");
    setsvalue(L,  &x2[3].uv , x6);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x6))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* run */
    CClosure* x7 = luaF_newCclosure(L, 1);
    x7->f = function_run_lua;
    setuvalue(L, &x7->upvalue[0], x1);
    TValue x8; setclCvalue(L, &x8, x7);
    setobj(L,  &x2[4].uv , &x8);
    if (iscollectable(&x8) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x8))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x9 = L->top;
    setuvalue(L, s2v(x9), x1); x9++;
    L->top = x9;
    lua_createtable(L, 0, 1);
    lua_pushstring(L, "run");
    setobj(L, s2v(L->top),  &x2[4].uv ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

