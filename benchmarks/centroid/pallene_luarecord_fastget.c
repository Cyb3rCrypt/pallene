/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

/* fixed hash layout for seed = 0
 * sizenode 2
 * pos 0	key string	str y	hash 152
 * pos 1	key string	str x	hash 153
 */

static void dumphashpart(lua_State *L, Table *t) {
    printf("sizenode %d\n", sizenode(t));
    for (int i = 0; i < sizenode(t); i++) {
        Node *n = gnode(t, i);
        int kt = novariant(n->u.key_tt);
        printf("pos %d\t", i);
        printf("key %s\t", ttypename(kt));
        if (kt == LUA_TSTRING) {
            TValue k;
            getnodekey(L, &k, n);
            TString *str = tsvalue(&k);
            printf("str %s\t", svalue(&k));
            printf("hash %d\t", str->hash);
        }
        printf("\n");
    }
    printf("---\n");
}

static const TValue *getstrfast(Table *t, TString *key, int hash, int pos)
{
#if 1
  if (pos < sizenode(t)) {
    Node *n = gnode(t, pos);
    if (keyisshrstr(n) && eqshrstr(keystrval(n), key))
      return gval(n);  /* that's it */
  }
#endif
  Node *n = gnode(t, lmod(hash, sizenode(t)));
  for (;;) {  /* check whether 'key' is somewhere in the chain */
    if (keyisshrstr(n) && eqshrstr(keystrval(n), key))
      return gval(n);  /* that's it */
    else {
      int nx = gnext(n);
      if (nx == 0)
        return luaH_emptyobject;  /* not found */
      n += nx;
    }
  }
}

static Table * function_new_pallene(
    lua_State * L,
    lua_Number x1 /* x */,
    lua_Number x2 /* y */
){
    CClosure * x3 = clCvalue(s2v(L->ci->func));
    Udata * x4 /* upvalue table */ = uvalue(&x3->upvalue[0]);
    UValue * x5 /* upvalue array */ = x4->uv;
    (void)x5;
    {
        luaC_condGC(L, {
        }, {
        });
        Table * x6 = luaH_new(L);
        luaH_resize(L, x6, 0, 2);
        TValue * x7 =  &x5[7].uv ;
        TString * x8 = tsvalue(x7);
        TValue x9;
        setsvalue(L, &x9, x8);
        TValue * x10 = luaH_newkey(L, x6, &x9);
        setfltvalue(x10, x1);
        TValue * x11 =  &x5[8].uv ;
        TString * x12 = tsvalue(x11);
        TValue x13;
        setsvalue(L, &x13, x12);
        TValue * x14 = luaH_newkey(L, x6, &x13);
        setfltvalue(x14, x2);
        return x6;
    }
}

static int function_new_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    int x5 /* nargs */ = cast_int(L->top - (x4 + 1));
    if (PALLENE_UNLIKELY(x5 != 2)) {
        pallene_runtime_arity_error(L, 2, x5);
    }
    TValue* x6 = s2v(x4 + 1);
    if (PALLENE_UNLIKELY(!ttisfloat(x6))) {
        pallene_runtime_argument_type_error(L, "x", 2, LUA_TNUMFLT, x6);
    }
    TValue* x7 = s2v(x4 + 2);
    if (PALLENE_UNLIKELY(!ttisfloat(x7))) {
        pallene_runtime_argument_type_error(L, "y", 2, LUA_TNUMFLT, x7);
    }
    lua_Number x8 = fltvalue(s2v(x4 + 1));
    lua_Number x9 = fltvalue(s2v(x4 + 2));
    Table * x10 /* ret */ = function_new_pallene(L, x8, x9);
    sethvalue(L, s2v(L->top), x10);
    api_incr_top(L);
    return 1;
}

static Table * function_centroid_pallene(
    lua_State * L,
    Table * x1 /* points */,
    lua_Integer x2 /* nrep */
){
    lua_checkstack(L, 1);
    CClosure * x3 = clCvalue(s2v(L->ci->func));
    Udata * x4 /* upvalue table */ = uvalue(&x3->upvalue[0]);
    UValue * x5 /* upvalue array */ = x4->uv;
    (void)x5;
    {
        lua_Number x6 /* x */ = 0x0p+0 /*0.000000*/;
        lua_Number x7 /* y */ = 0x0p+0 /*0.000000*/;
        lua_Integer x8 = luaH_getn(x1);
        lua_Integer x9 /* npoints */ = x8;
        lua_Integer x10 /* start */ = 1;
        lua_Integer x11 /* limit */ = x2;
        lua_Integer x12 /* step */ = 1;
        while ((x12 >= 0 ? x10 <= x11 : x10 >= x11)) {
            lua_Integer x13 /* _ */ = x10;
            (void) x13;
            {
                x6 = 0x0p+0 /*0.000000*/;
                x7 = 0x0p+0 /*0.000000*/;
                lua_Integer x14 /* start */ = 1;
                lua_Integer x15 /* limit */ = x9;
                lua_Integer x16 /* step */ = 1;
                while ((x16 >= 0 ? x14 <= x15 : x14 >= x15)) {
                    lua_Integer x17 /* i */ = x14;
                    (void) x17;
                    {
                        lua_Unsigned x18 /* ui */ = ((lua_Unsigned)x17) - 1;
                        const TValue * x19 /* arrslot */;
                        if (PALLENE_LIKELY(x18 < x1->sizearray)) {
                            x19 = &x1->array[x18];
                        }
                        else {
                            x19 = (TValue *)luaH_getint(x1, x17);
                        }
                        if (PALLENE_UNLIKELY(!ttistable(x19))) {
                            pallene_runtime_array_type_error(L, 14, LUA_TTABLE, rawtt(x19));
                        }
                        Table * x20 = hvalue(x19);
                        Table * x21 /* p */ = x20;
                        TValue * x23 =  &x5[7].uv ;
                        TString * x24 = tsvalue(x23);
                        TValue * x25 = (TValue *)getstrfast(x21, x24, 153, 1);
                        if (PALLENE_UNLIKELY(!ttisfloat(x25))) {
                            pallene_runtime_lrecord_type_error(
                                L, "x", 15, LUA_TNUMFLT, rawtt(x25)
                            );
                        }
                        lua_Number x22 = fltvalue(x25);
                        lua_Number x26 = x6 + x22;
                        x6 = x26;
                        TValue * x28 =  &x5[8].uv ;
                        TString * x29 = tsvalue(x28);
                        TValue * x30 = (TValue *)getstrfast(x21, x29, 152, 0);
                        if (PALLENE_UNLIKELY(!ttisfloat(x30))) {
                            pallene_runtime_lrecord_type_error(
                                L, "y", 16, LUA_TNUMFLT, rawtt(x30)
                            );
                        }
                        lua_Number x27 = fltvalue(x30);
                        lua_Number x31 = x7 + x27;
                        x7 = x31;
                    }
                    x14 = intop(+, x14, x16);
                }
            }
            x10 = intop(+, x10, x12);
        }
        luaC_condGC(L, {
            StackValue* x32 = L->top;
            sethvalue(L, s2v(x32), x1); x32++;
            L->top = x32;
        }, {
            L->top -= 1;
        });
        Table * x33 = luaH_new(L);
        luaH_resize(L, x33, 0, 2);
        lua_Number x34 = (lua_Number) x9;
        lua_Number x35 = x6 / x34;
        TValue * x36 =  &x5[7].uv ;
        TString * x37 = tsvalue(x36);
        TValue x38;
        setsvalue(L, &x38, x37);
        TValue * x39 = luaH_newkey(L, x33, &x38);
        setfltvalue(x39, x35);
        lua_Number x40 = (lua_Number) x9;
        lua_Number x41 = x7 / x40;
        TValue * x42 =  &x5[8].uv ;
        TString * x43 = tsvalue(x42);
        TValue x44;
        setsvalue(L, &x44, x43);
        TValue * x45 = luaH_newkey(L, x33, &x44);
        setfltvalue(x45, x41);
        return x33;
    }
}

static int function_centroid_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    int x5 /* nargs */ = cast_int(L->top - (x4 + 1));
    if (PALLENE_UNLIKELY(x5 != 2)) {
        pallene_runtime_arity_error(L, 2, x5);
    }
    TValue* x6 = s2v(x4 + 1);
    if (PALLENE_UNLIKELY(!ttistable(x6))) {
        pallene_runtime_argument_type_error(L, "points", 6, LUA_TTABLE, x6);
    }
    TValue* x7 = s2v(x4 + 2);
    if (PALLENE_UNLIKELY(!ttisinteger(x7))) {
        pallene_runtime_argument_type_error(L, "nrep", 6, LUA_TNUMINT, x7);
    }
    Table * x8 = hvalue(s2v(x4 + 1));
    lua_Integer x9 = ivalue(s2v(x4 + 2));
    Table * x10 /* ret */ = function_centroid_pallene(L, x8, x9);
    sethvalue(L, s2v(L->top), x10);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_centroid_pallene_luarecord_fastget(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Udata * x1 = luaS_newudata(L, 0, 11);
    UValue * x2 = x1->uv;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0].uv , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__newindex");
    setsvalue(L,  &x2[1].uv , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x5 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[2].uv , x5);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x5))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x6 = luaS_new(L, "x");
    setsvalue(L,  &x2[3].uv , x6);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x6))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x7 = luaS_new(L, "y");
    setsvalue(L,  &x2[4].uv , x7);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x7))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x8 = luaS_new(L, "x");
    setsvalue(L,  &x2[5].uv , x8);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x8))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x9 = luaS_new(L, "y");
    setsvalue(L,  &x2[6].uv , x9);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x9))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x10 = luaS_new(L, "x");
    setsvalue(L,  &x2[7].uv , x10);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x10))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x11 = luaS_new(L, "y");
    setsvalue(L,  &x2[8].uv , x11);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x11))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* new */
    CClosure* x12 = luaF_newCclosure(L, 1);
    x12->f = function_new_lua;
    setuvalue(L, &x12->upvalue[0], x1);
    TValue x13; setclCvalue(L, &x13, x12);
    setobj(L,  &x2[9].uv , &x13);
    if (iscollectable(&x13) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x13))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* centroid */
    CClosure* x14 = luaF_newCclosure(L, 1);
    x14->f = function_centroid_lua;
    setuvalue(L, &x14->upvalue[0], x1);
    TValue x15; setclCvalue(L, &x15, x14);
    setobj(L,  &x2[10].uv , &x15);
    if (iscollectable(&x15) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x15))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x16 = L->top;
    setuvalue(L, s2v(x16), x1); x16++;
    L->top = x16;
    lua_createtable(L, 0, 2);
    lua_pushstring(L, "new");
    setobj(L, s2v(L->top),  &x2[9].uv ); api_incr_top(L);
    lua_settable(L, -3);
    lua_pushstring(L, "centroid");
    setobj(L, s2v(L->top),  &x2[10].uv ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

