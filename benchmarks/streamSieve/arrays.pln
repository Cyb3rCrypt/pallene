
-- Simple streams library for building infinite lists.
-- Based on the implementation from Racket, but modified to use explicit
-- parameters instead of closures

type Stream = {any}

local function make_stream(head: any, state: any, get_tail: any): Stream
    return { head, state, get_tail }
end

local function stream_head(st: Stream): any
    return st[1]
end

local function stream_tail(st: Stream): Stream
    local f = st[3] as any->Stream
    return f(st[2])
end

local function stream_get(st: Stream, n: integer): any
    for _ = 1, n-1 do
        st = stream_tail(st)
    end
    return stream_head(st)
end

----------------------------------------------

-- Build a stream of integers starting from 1

local function count_from(n: integer): Stream
    return make_stream(n, n, _tail1)
end

local function _tail1(i: integer): Stream
    return count_from(i+1)
end

-- Filter all multiples of n

local function sift(n: integer, st: Stream): Stream
    local hd = stream_head(st) as integer
    local tl = stream_tail(st)
    while hd % n == 0 do
        st = tl
        hd = stream_head(st) as integer
        tl = stream_tail(st)
    end
    local state = { n, tl } as {any}
    return make_stream(hd, state, _tail2)
end

local function _tail2(state: {any}): Stream
    return sift(state[1] as integer, state[2] as any)
end

-- Naive sieve of Erasthostenes

local function sieve(st: Stream): Stream
    local n  = stream_head(st)
    local tl = stream_tail(st)
    local state = { n, tl } as {any}
    return make_stream(n, state, _tail3)
end

local function _tail3(state: {any}): Stream
    return sieve(sift(state[1], state[2]))
end

--

function get_prime(n: integer): integer
    local prime_stream = sieve(count_from(2))
    return stream_get(prime_stream, n)
end


